{% comment %}
Template returned for requests to /iframe. The iframe serves as a proxy for Sentry API requests.
Required context variables:
- referrer:           string.       HTTP header from the request object.
- state:              string.       One of: `logged-out`, `missing-project`, `invalid-domain` or `success`.
- logging:            any.          If the value is truthy in JavaScript then debug logging will be enabled.
- organization_slug:  string.       The org named in the url params
- project_id_or_slug: string | int. The project named in the url params
{% endcomment %}
{% load sentry_helpers %}
{% load sentry_assets %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Sentry DevToolbar iFrame</title>
    <link rel="icon" type="image/png" href="{% absolute_asset_url "sentry" "images/favicon.png" %}">
  </head>
  <body>
    <form id="login-form">
      <button type="submit">Log in</button>
    </form>

    {% script %}
    <script>
      (function() {
        const referrer = '{{ referrer|escapejs }}';
        const state = '{{ state|escapejs }}';
        const logging = '{{ logging|escapejs }}';
        const organizationSlug = '{{ organization_slug|escapejs }}';
        const projectIdOrSlug = '{{ project_id_or_slug|escapejs }}';

        function log(...args) {
          if (logging) {
            console.log('/toolbar/:org/:project/iframe/', ...args);
          }
        }

        let loginFormSetup = false;
        function setupLoginForm() {
          log('setupLoginForm()');
          if (loginFormSetup) return;
          const form = document.getElementById('login-form');
          form.addEventListener('submit', submitEvent => {
            submitEvent.preventDefault();
            window.open(
              `/toolbar/${organizationSlug}/${projectIdOrSlug}/login-success/`,
              'sentry-toolbar-auth-popup',
              'popup=true,innerWidth=800,innerHeight=550,noopener=false'
            );
          });
          loginFormSetup = true;
        }

        function listenForLoginSuccess() {
          window.addEventListener('message', messageEvent => {
            if (messageEvent.origin !== document.location.origin || messageEvent.data.source !== 'sentry-toolbar') {
              return;
            }

            log('window.onMessage', messageEvent.data, messageEvent);
            if (messageEvent.data.message === 'did-login') {
              saveAccessToken(messageEvent.data);
              setupMessageChannel();
            }
          });
        }

        function saveAccessToken(data) {
          log('saveAccessToken', data);
          let tokenValue;
          let tokenType;

          if (data.cookie) {
            tokenValue = data.cookie;
            tokenType = "cookie";
            document.cookie = `${tokenValue}; domain=${window.location.hostname}; path=/; max-age=31536000; SameSite=none; partitioned; secure`;
            log('Saved a cookie', document.cookie.indexOf(cookie) >= 0, cookie);
          } else if (data.token) {
            tokenValue = data.token;
            tokenType = "accessToken";
          }
          else {
            log('Unexpected: No access token or cookie found!');
            return;
          }

          try {
            localStorage.setItem(tokenType, tokenValue);
            log(`Saved {tokenType} to localStorage`, tokenValue);
          } catch (err) {
            log("Failed to use local storage:", err);
          }
        }

        function setupMessageChannel() {
          log('setupMessageChannel()');
          log('state:', { state });

          if (state !== 'success') {
            // enum of: logged-out, missing-project, invalid-domain
            window.parent.postMessage({
              source: 'sentry-toolbar',
              message: state
            }, referrer);
            setupLoginForm();
            listenForLoginSuccess();
            return;
          }

          // Never, ever setup up the channel unless state is "success"

          const { port1, port2 } = new MessageChannel();

          const messageDispatch = {
            'log': log,
            'fetch': async (url, init) => {
              // For mock/test purposes we're fetching the accessToken and injecting it
              const accessToken = localStorage.getItem('accessToken')
              const bearer = accessToken ? { 'Authorization': `Bearer ${accessToken}` } : {};

              log('Found access info', {cookie: document.cookie, accessToken, lsCookie: localStorage.getItem('cookie')});

              const initWithCreds = {
                ...init,
                headers: { ...init.headers, ...bearer },
                credentials: 'same-origin',
              };
              log({initWithCreds});

              const response = await fetch(url, initWithCreds);
              return {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                url: response.url,
                headers: Object.fromEntries(response.headers.entries()),
                text: await response.text(),
              };
            },
          };
          // This is critical as when using the `in` operator, one can access
          // built-in special functions such as `__defineGetter__` etc and then
          // inject their own code/functions or break out.
          const validFunctions = new Set(Object.keys(messageDispatch));

          port1.addEventListener('message', messageEvent => {
            log('port.onMessage', messageEvent.data);

            const { $id, message } = messageEvent.data;
            if (!$id || !message) {
              return; // MessageEvent is malformed, missing $id
            }

            const {$function, $args} = message;
            if (!$function || !validFunctions.has($function)) {
              return; // No-op without a $function to call or invalid function name
            }

            messageDispatch[$function](...($args || []))
              .then(
                $result => port1.postMessage({ $id, $result }),
                $error => port1.postMessage({ $id, $error })
              );
          });
          port1.start();

          window.parent.postMessage({
            source: 'sentry-toolbar',
            message: 'port-connect',
          }, referrer, [port2]);

          log('Sent', { message: 'port-connect', referrer });
        }

        log('Init', { referrer, state });

        setupMessageChannel();
      })();
    </script>
    {% endscript %}

{% comment %}
No need to close `body`. If we do then middleware will inject some extra markup
we don't need. Browsers can figure out when it missing and deal with it.
{% endcomment %}
